关于 Inode 的设计：
1. 配合 InodeCache 加快查找效率，实现文件的缓存
2. 关于 file 与 page cache 字段:
   - 由于该设计为全国赛第一阶段结束后进行的设计，可能来不及重新设计 fat32 文件系统以及在内核中实现 tempfs,
     内核统一借用 fat32 文件系统提供的 VirtFile 作为内核操作文件的对象
   - 在全国赛第一阶段提交过程中，我们发现我们的文件系统设计不足导致运行速度非常缓慢。第一阶段结束后，我们通过自己的分析，
     解决了 fat32 库因为查找簇链表的效率过低导致的问题，但仍为大量的对磁盘/sdcard直接读写导致的效率问题而困扰，
     于是寻到了同一届的 TitanixOS。
   - 我们非常欣赏 TitanixOS 的设计，TitanixOS 的文件与文件系统结构与功能设计非常优秀，对比起来，
     我们的内核文件设计稍显简陋 - 主要说与 fat32 文件耦合严重。
     但学习了 Titanix 关于 PageCache 的设计后，我们为内核文件加入页缓存机制，相当于创建出虚拟的 tempfs, 大大提高了执行效率
3. 关于 file_size 字段（在 Inode 中保存文件的大小的理由）:
   - 在内核运行过程中，创建的文件往往是直接在内存上映射的，可以将这些文件视为虚拟出的 tempfs 所管理的文件。
   - 这些在内核运行时创建的文件的读写操作实际上是在内存中通过 Page Cache 进行的，往往不会直接写回文件系统，
     因为单核下，大量的对磁盘的直接读写会导致内核执行速度非常缓慢
   - 由于文件读写过程中需要用到 file_size 参数，加上不会每次写文件或关闭文件后直接写回文件系统，
     故不能通过在文件系统中读取文件大小的方式来获取文件大小（不一致）
   - 由于不同进程对该文件进行写操作时会改写文件的大小，使用 Inode Cache 再次打开文件时必须保证文件大小的一致性。

关于内核文件的实现：
  由于我们内核的文件与 fat32 文件系统存在耦合（内核文件基于 fat32 文件），对于某些测试中要求内核必须有的文件/目录，必须预先在次处创建
  其实更合理的解决方案是在内核中实现 tempfs，但是目前我们马上进入全国赛第二阶段，暂时没有时间改进内核文件系统。
  若以后参赛队伍参考我们文件系统部分的代码实现的话，推荐参考与我们的同一届参赛队伍 TitanixOS 文件系统的实现。
  简单来说，TitanixOS 的所有文件基本是在内核中实现的，而不是基于 fat32 文件系统。我们也是参考了 Titanix 的页缓存设计思路，大大提高了我们测试时的运行速度。
  TitanixOS 似乎仅仅从 FAT32 文件系统中读取测试文件/程序。